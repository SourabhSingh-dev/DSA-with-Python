# ğŸ—“ï¸ Day 10 â€“ 08/08/2025

### ğŸ“ Status: âœ… Completed

---

## âœ… What I did today:

* ğŸ“Œ **Topic:** Arrays â€“ Two Pointer Technique (In-Place Partitioning)
  - âœ… Solved `Sort Array By Parity` from LeetCode
  - âœ… Explored multiple approaches:
    - List concatenation (O(n) time, O(n) space)
    - Two-pointer with many branches (O(n) time, O(1) space)
    - Corrected minimal-branch two-pointer (O(n) time, O(1) space, faster in Python)
  - âœ… Learned when â€œin-placeâ€ optimizations can be slower in Python due to branching overhead
  - âœ… Practiced dry runs to confirm pointer movement logic
  - âœ… Maintained clean Notion notes with code comparisons

* ğŸ“˜ **Resources:**
  - LeetCode Problem: Sort Array By Parity
  - Self-debugging + pattern refinement through discussion

---

## ğŸ’» Problem Solved:
- `sort_array_by_parity.py` âœ… (Two Pointer, In-Place Partitioning)

---

## ğŸ§  Reflections:
* Realized that **algorithmic complexity** isnâ€™t the only factor â€” fewer branches and simpler loops often run faster in Python
* Understood the **pointer movement discipline** in partitioning problems to avoid skipping elements
* Caught the logical swap-condition bug in one version and fixed it to only swap when needed
* Learned that the most â€œmemory-optimalâ€ solution isnâ€™t always the most runtime-optimal in Python

---

## ğŸ”„ Next Up:
* Continue with more **Two Pointer** partitioning problems
* Explore similar parity/condition-based rearrangement tasks
* Track performance differences between Python and lower-level implementations for the same logic

---
